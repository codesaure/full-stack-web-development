# COMMUNICATING WITH SERVER

## RENDERING A COLLECTION, MODULES

### console.log
When you use the command console.log for debugging,separate the things to be printed with a comma

`console.log('props value is', props)`

### Protip: VS Code snippets
Create [code snippets](https://code.visualstudio.com/docs/editing/userdefinedsnippets#_creating-your-own-snippets) in VSCode

The most important snippet is the one for the console.log() command, for example, clog.
This can be created like so:
```
{
  "console.log": {
    "prefix": "clog",
    "body": [
      "console.log('$1')",
    ],
    "description": "Log output to console"
  }
}
```
Debugging your code using **console.log()** is so common that Visual Studio Code has that snippet built in.
To use it, type **log** and hit Tab to autocomplete. 

### JavaScript Arrays

If operating arrays with functional operators feels foreign to you, it is worth watching at least the first three parts of the YouTube video series Functional Programming in JavaScript:

Higher-order functions
Map
Reduce basics

Filter
const numbers = [1, 2, 3, 4, 5];

const evenNumbers = numbers.filter(n => n % 2 === 0);

console.log(evenNumbers); // [2, 4]

Map
const numbers = [1, 2, 3, 4, 5];

const squares = numbers.map(n => n * n);

console.log(squares); // [1, 4, 9, 16, 25]

Map always creates a new array, the elements of which have been created from the elements of the original array by mapping: using the function given as a parameter to the map method.

The list items, i.e. the elements generated by the map method, must each have a unique key value: an attribute called key.
React uses the key attributes of objects in an array to determine how to update the view generated by a component when the component is re-rendered. 


### Event Handlers Revisited

### Rendering Collections

### Key-attribute

### Map
Understanding how the array method [map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) works is crucial for the rest of the course.

### Anti-pattern: Array Indexes as Keys

### Refactoring Modules

### When the app breaks

Because the first thing to be rendered is the App component, it's worth putting the first console.log there.

If the component has been declared as a single statement or a function without a return, it makes printing to the console harder.
```
const Course = ({ course }) => (
  <div>
    <Header course={course} />
  </div>
)
```
The component should be changed to its longer form for us to add the printing:
```
const Course = ({ course }) => { 

  console.log(course)
  return (
    <div>
      <Header course={course} />
    </div>
  )
}
```

Quite often the root of the problem is that the props are expected to be of a different type, or called with a different name than they actually have, and destructuring fails as a result. The problem often begins to solve itself when destructuring is removed and we see what the props contain.

```
const Course = (props) => {
  console.log(props)
  const { course } = props
  return (
    <div>
      <Header course={course} />
    </div>
  )
}
```


Key-attribute
List items, i.e. the elements generated by the map method, must each have a unique key value: an attribute called key.
React uses the key attributes of objects in an array to determine how to update the view generated by a component when the component is re-rendered. More about this is in the React documentation.
Anti-pattern: Array Indexes as Keys. Not recommended and can create undesired problems even if it seems to be working just fine.
The key attribute must now be defined for the React Component, and not for the li tags like before.







## FORMS

### Saving the notes in the component state

### Controlled component

### Filtering Displayed Elements

```const addNote = (event) => {
  event.preventDefault()
  console.log('button clicked', event.target)
}
```
The event parameter is the event that triggers the call to the event handler function
event.preventDefault() method, which prevents the default action of submitting a form. The default action would, among other things, cause the page to reload.
The target in this case is the form that we have defined in our component.

How do we access the data contained in the form's input element?

the first method we will take a look at is through the use of so-called [controlled components.](https://react.dev/reference/react-dom/components/input#controlling-an-input-with-a-state-variable)

Since we assigned a piece of the App component's state as the value attribute of the input element, the App component now controls the behavior of the input element.
To enable editing of the input element, we have to register an event handler that synchronizes the changes made to the input with the component's state. Registered an event handler to the onChange attribute of the form's input element

When you are forming strings that contain values from variables, it is recommended to use a template string:
`${newName} is already added to phonebook`

## GETTING DATA FROM SERVER

### The browser as a runtime environment

### npm

### Axios and promises
A Promise is an object representing the eventual completion or failure of an asynchronous operation.

In other words, a promise is an object that represents an asynchronous operation. A promise can have three distinct states:

* Pending: It means that the asynchronous operation corresponding to the promise has not yet finished and the final value is not available yet.
* Fulfilled: It means that the operation has been completed and the final value is available, which generally is a successful operation.
* Rejected: It means that an error prevented the final value from being determined, which generally represents a failed operation.

If, and when, we want to access the result of the operation represented by the promise, we must register an event handler to the promise. 
This is achieved using the method then:
```
const promise = axios.get('http://localhost:3001/notes')

promise.then(response => {
  console.log(response)
})
```
A more readable way to format chained method calls is to place each call on its own line:
```
axios
  .get('http://localhost:3001/notes')
  .then(response => {
    const notes = response.data
    console.log(notes)
  })
```
### Effect-hooks
Effects let a component connect to and synchronize with external systems.
This includes dealing with network, browser DOM, animations, widgets written using a different UI library, and other non-React code.
Effect hooks are precisely the right tool to use when fetching data from a server.

First, the body of the function defining the component is executed and the component is rendered for the first time

The function useEffect takes two parameters. The first is a function, the effect itself. According to the documentation:

By default, effects run after every completed render, but you can choose to fire it only when certain values have changed.

So by default, the effect is always run after the component has been rendered. In our case, however, we only want to execute the effect along with the first render.

The second parameter of useEffect is used to specify how often the effect is run. If the second parameter is an empty array [], then the effect is only run along with the first render of the component.

You can start the JSON Server without a separate installation by running the following npx command in the root directory of the application:
npx json-server --port 3001 db.json
The JSON Server starts running on port 3000 by default, but we will now define an alternate port 3001. 

Install json-server as a development dependency (only used during development) by executing the command:
`npm install json-server --save-dev`

making a small addition to the scripts part of the package.json file under scripts
"server": "json-server -p 3001 db.json"
We can now conveniently, without parameter definitions, start the json-server from the project root directory with the command:
npm run server

We will be using the [axios](https://github.com/axios/axios) library
Another good reason to use axios is our getting familiar with adding external libraries, so-called npm packages, to React projects.
Nowadays, practically all JavaScript projects are defined using the node package manager, aka npm. The projects created using Vite also follow the npm format. A clear indicator that a project uses npm is the package.json file located at the root of the project

Install axios from the command line:
`npm install axios`
npm-commands should always be run in the project root directory, which is where the package.json file can be found.

### The development runtime environment






## ALTERING DATA IN SERVER

### REST

### Sending Data to the Server

### Changing the importance of Notes

### Extracting Communication with the Backend into a Separate Module

### Cleaner Syntax for Defining Object Literals

### Promises and Errors
The rejection of a promise is handled by providing the then method with a second callback function, which is called in the situation where the promise is rejected.

The more common way of adding a handler for rejected promises is to use the catch method.
```
axios
  .get('http://example.com/probably_will_fail')
  .then(response => {
    console.log('success!')
  })
  .catch(error => {
    console.log('fail')
  })
```
If the request fails, the event handler registered with the catch method gets called.

The catch method is often utilized by placing it deeper within the promise chain.

It's probably not a good idea to use the alert dialog popup in more serious React applications

## ADDING STYLES TO REACT APP
```
h1 {
  color: green;
}
```

CSS rules comprise of selectors and declarations. 
The selector defines which elements the rule should be applied to. The selector above is h1, which will match all of the h1 header tags in our application.
The declaration sets the color property to the value green.
Using element types for defining CSS rules is slightly problematic. If our application contained other li tags, the same style rule would also be applied to them.
If we want to apply our style specifically to notes, then it is better to use [class selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/Class_selectors).

In React we have to use the [className](https://react.dev/learn#adding-styles) attribute instead of the class attribute.

`<li className='note'>`

Class selectors are defined with the .classname syntax:

```.note {
  color: grey;
  padding-top: 5px;
  font-size: 15px;
}
```
### Improved error message

Implement the error message as its own React component.
```
const Notification = ({ message }) => {
  if (message === null) {
    return null
  }

  return (
    <div className='error'>
      {message}
    </div>
  )
}
```

If the value of the message prop is null, then nothing is rendered to the screen, and in other cases, the message gets rendered inside of a div element.

### Inline Styles

But as a React inline-style object it would look like this:

```{
  color: 'green',
  fontStyle: 'italic'
}
```

Every CSS property is defined as a separate property of the JavaScript object. Numeric values for pixels can be simply defined as integers. 

One of the major differences compared to regular CSS, is that hyphenated (kebab case) CSS properties are written in camelCase.

```
  const footerStyle = {
    color: 'green',
    fontStyle: 'italic'
  }
```

`<div style={footerStyle}>`

Inline styles come with certain limitations. For instance, so-called [pseudo-classes](https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes) can't be used straightforwardly.

Since the separation of CSS, HTML, and JavaScript into separate files did not seem to scale well in larger applications, React bases the division of the application along the lines of its logical functional entities.

The structural units that make up the application's functional entities are React components. A React component defines the HTML for structuring the content, the JavaScript functions for determining functionality, and also the component's styling; all in one place. This is to create individual components that are as independent and reusable as possible.

## Couple of important remarks